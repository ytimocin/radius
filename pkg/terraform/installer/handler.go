/*
Copyright 2024 The Radius Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package installer

import (
	"archive/zip"
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"hash"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/go-logr/logr"
	"github.com/radius-project/radius/pkg/components/queue"
	"github.com/radius-project/radius/pkg/ucp/ucplog"
)

var (
	// ErrInstallerBusy indicates another installer operation is already running.
	ErrInstallerBusy = errors.New("installer is busy; another operation is in progress")
)

// Handler processes installer queue messages.
type Handler struct {
	StatusStore StatusStore
	RootPath    string
	HTTPClient  *http.Client
	// BaseURL optionally overrides the default Terraform releases base URL (for mirrors/air-gapped).
	BaseURL string
}

// Handle processes a queue message.
func (h *Handler) Handle(ctx context.Context, msg *queue.Message) error {
	payload := &JobMessage{}
	if err := json.Unmarshal(msg.Data, payload); err != nil {
		return fmt.Errorf("failed to decode installer job: %w", err)
	}

	switch payload.Operation {
	case OperationInstall:
		return h.handleInstall(ctx, payload)
	case OperationUninstall:
		return h.handleUninstall(ctx, payload)
	default:
		return fmt.Errorf("unsupported installer operation: %s", payload.Operation)
	}
}

func (h *Handler) handleInstall(ctx context.Context, job *JobMessage) error {
	log := ucplog.FromContextOrDiscard(ctx)

	if err := h.ensureRoot(); err != nil {
		return err
	}
	lockFile, err := h.acquireLock()
	if err != nil {
		log.Error(err, "installer lock acquisition failed")
		return err
	}
	defer h.releaseLock(log, lockFile)

	start := time.Now()

	status, err := h.getOrInitStatus(ctx)
	if err != nil {
		return err
	}

	vs := status.Versions[job.Version]
	vs.Version = job.Version
	vs.SourceURL = job.SourceURL
	vs.Checksum = job.Checksum
	vs.State = VersionStateInstalling
	vs.LastError = ""
	if vs.Health == "" {
		vs.Health = HealthUnknown
	}
	status.Versions[job.Version] = vs
	if err := h.persistStatus(ctx, status); err != nil {
		return err
	}

	sourceURL := job.SourceURL
	if strings.TrimSpace(sourceURL) == "" {
		if strings.TrimSpace(job.Version) == "" {
			return errors.New("version or sourceUrl is required")
		}
		sourceURL = h.defaultTerraformURL(job.Version)
	}

	targetDir := filepath.Join(h.rootPath(), "versions", job.Version)
	if err := os.MkdirAll(targetDir, 0o755); err != nil {
		return fmt.Errorf("failed to create target dir: %w", err)
	}

	archivePath := filepath.Join(targetDir, "terraform-download")
	if err := h.download(ctx, sourceURL, archivePath, job.Checksum); err != nil {
		_ = h.recordFailure(ctx, status, job.Version, err)
		return err
	}

	binaryPath := filepath.Join(targetDir, "terraform")
	if err := h.stageBinary(ctx, archivePath, binaryPath); err != nil {
		_ = h.recordFailure(ctx, status, job.Version, err)
		return err
	}

	if err := os.Chmod(binaryPath, 0o755); err != nil {
		return fmt.Errorf("failed to chmod terraform binary: %w", err)
	}

	// Update status to succeeded and move pointers.
	vs.State = VersionStateSucceeded
	vs.Health = HealthHealthy
	vs.InstalledAt = time.Now().UTC()
	status.Previous = status.Current
	status.Current = job.Version
	status.Versions[job.Version] = vs
	status.LastError = ""
	if err := h.updateCurrentSymlink(binaryPath); err != nil {
		return err
	}
	if err := h.persistStatus(ctx, status); err != nil {
		return err
	}

	log.Info("installed terraform", "version", job.Version, "path", binaryPath, "duration", time.Since(start))
	return nil
}

func (h *Handler) handleUninstall(ctx context.Context, job *JobMessage) error {
	log := ucplog.FromContextOrDiscard(ctx)

	if err := h.ensureRoot(); err != nil {
		return err
	}
	lockFile, err := h.acquireLock()
	if err != nil {
		log.Error(err, "installer lock acquisition failed")
		return err
	}
	defer h.releaseLock(log, lockFile)

	start := time.Now()

	status, err := h.getOrInitStatus(ctx)
	if err != nil {
		return err
	}

	if status.Versions == nil {
		return fmt.Errorf("version %s not found", job.Version)
	}
	if status.Current == job.Version {
		return fmt.Errorf("cannot uninstall active version %s", job.Version)
	}

	vs, ok := status.Versions[job.Version]
	if !ok {
		return fmt.Errorf("version %s not found", job.Version)
	}

	vs.State = VersionStateUninstalling
	status.Versions[job.Version] = vs
	if err := h.persistStatus(ctx, status); err != nil {
		return err
	}

	targetDir := filepath.Join(h.rootPath(), "versions", job.Version)
	if err := os.RemoveAll(targetDir); err != nil {
		_ = h.recordFailure(ctx, status, job.Version, err)
		return err
	}

	vs.State = VersionStateUninstalled
	vs.Health = HealthUnknown
	vs.LastError = ""
	status.Versions[job.Version] = vs
	if err := h.persistStatus(ctx, status); err != nil {
		return err
	}

	log.Info("uninstalled terraform", "version", job.Version, "path", targetDir, "duration", time.Since(start))
	return nil
}

func (h *Handler) download(ctx context.Context, url, dst, checksum string) error {
	client := h.HTTPClient
	if client == nil {
		client = http.DefaultClient
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return err
	}

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("download failed with status %d", resp.StatusCode)
	}

	tmp := dst + ".tmp"
	out, err := os.Create(tmp)
	if err != nil {
		return err
	}
	defer out.Close()

	hasher := newHasher(checksum)
	if checksum != "" && hasher == nil {
		return fmt.Errorf("invalid checksum format")
	}
	if hasher != nil {
		if _, err := io.Copy(io.MultiWriter(out, hasher), resp.Body); err != nil {
			return err
		}
		if err := hasher.verify(); err != nil {
			return err
		}
	} else {
		if _, err := io.Copy(out, resp.Body); err != nil {
			return err
		}
	}

	if err := out.Close(); err != nil {
		return err
	}

	return os.Rename(tmp, dst)
}

func (h *Handler) stageBinary(ctx context.Context, archivePath, targetPath string) error {
	if strings.EqualFold(filepath.Ext(archivePath), ".zip") {
		return extractZip(archivePath, targetPath)
	}

	// Treat as plain binary.
	return copyFile(archivePath, targetPath)
}

func (h *Handler) updateCurrentSymlink(targetBinary string) error {
	currentLink := filepath.Join(h.rootPath(), "current")
	if err := os.Remove(currentLink); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove current symlink: %w", err)
	}
	return os.Symlink(targetBinary, currentLink)
}

func (h *Handler) rootPath() string {
	if h.RootPath == "" {
		return "/terraform"
	}
	return h.RootPath
}

func (h *Handler) defaultTerraformURL(version string) string {
	base := strings.TrimSuffix(h.BaseURL, "/")
	if base == "" {
		base = "https://releases.hashicorp.com"
	}

	arch := runtime.GOARCH
	switch arch {
	case "amd64":
		arch = "amd64"
	case "arm64":
		arch = "arm64"
	}
	return fmt.Sprintf("%s/terraform/%s/terraform_%s_%s_%s.zip", base, version, version, runtime.GOOS, arch)
}

type sha256Verifier struct {
	expected []byte
	sum      hash.Hash
}

func newHasher(checksum string) *sha256Verifier {
	if strings.TrimSpace(checksum) == "" {
		return nil
	}

	trimmed := checksum
	if strings.Contains(checksum, ":") {
		parts := strings.SplitN(checksum, ":", 2)
		trimmed = parts[1]
	}
	expected, err := hex.DecodeString(trimmed)
	if err != nil || len(expected) != sha256.Size {
		return nil
	}

	return &sha256Verifier{
		expected: expected,
		sum:      sha256.New(),
	}
}

func (v *sha256Verifier) Write(p []byte) (int, error) {
	return v.sum.Write(p)
}

func (v *sha256Verifier) verify() error {
	if v == nil {
		return nil
	}
	if !bytes.Equal(v.sum.Sum(nil), v.expected) {
		return fmt.Errorf("checksum mismatch")
	}
	return nil
}

func extractZip(src, targetPath string) error {
	r, err := zip.OpenReader(src)
	if err != nil {
		return err
	}
	defer r.Close()

	extracted := false
	for _, f := range r.File {
		if f.FileInfo().IsDir() {
			continue
		}
		if extracted {
			return fmt.Errorf("archive contains multiple files")
		}
		rc, err := f.Open()
		if err != nil {
			return err
		}
		defer rc.Close()

		if err := writeFile(rc, targetPath, f.Mode()); err != nil {
			return err
		}
		extracted = true
	}
	if !extracted {
		return fmt.Errorf("no file found in archive")
	}
	return nil
}

func copyFile(src, dst string) error {
	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer in.Close()

	return writeFile(in, dst, 0o755)
}

func writeFile(r io.Reader, dst string, perm os.FileMode) error {
	tmp := dst + ".tmp"
	out, err := os.Create(tmp)
	if err != nil {
		return err
	}
	defer out.Close()

	if _, err := io.Copy(out, r); err != nil {
		return err
	}

	if err := out.Close(); err != nil {
		return err
	}

	if perm != 0 {
		if err := os.Chmod(tmp, perm); err != nil {
			return err
		}
	}

	return os.Rename(tmp, dst)
}

func (h *Handler) getOrInitStatus(ctx context.Context) (*Status, error) {
	status, err := h.StatusStore.Get(ctx)
	if err != nil {
		return nil, err
	}
	if status.Versions == nil {
		status.Versions = map[string]VersionStatus{}
	}
	return status, nil
}

func (h *Handler) persistStatus(ctx context.Context, status *Status) error {
	status.LastUpdated = time.Now().UTC()
	if err := h.StatusStore.Put(ctx, status); err != nil {
		ucplog.FromContextOrDiscard(ctx).Error(err, "failed to persist installer status")
		return err
	}
	return nil
}

func (h *Handler) recordFailure(ctx context.Context, status *Status, version string, cause error) error {
	vs := status.Versions[version]
	vs.State = VersionStateFailed
	vs.LastError = cause.Error()
	vs.Health = HealthUnhealthy
	status.Versions[version] = vs
	status.LastError = cause.Error()
	return h.persistStatus(ctx, status)
}

func (h *Handler) acquireLock() (*os.File, error) {
	lockPath := filepath.Join(h.rootPath(), ".terraform-installer.lock")
	f, err := os.OpenFile(lockPath, os.O_CREATE|os.O_EXCL|os.O_RDWR, 0o600)
	if err != nil {
		if os.IsExist(err) {
			return nil, ErrInstallerBusy
		}
		return nil, fmt.Errorf("failed to acquire installer lock: %w", err)
	}
	return f, nil
}

func (h *Handler) releaseLock(log logr.Logger, f *os.File) {
	if f == nil {
		return
	}
	lockPath := f.Name()
	_ = f.Close()
	if err := os.Remove(lockPath); err != nil && !os.IsNotExist(err) {
		log.Error(err, "failed to remove installer lock file", "path", lockPath)
	}
}

func (h *Handler) ensureRoot() error {
	return os.MkdirAll(h.rootPath(), 0o755)
}
